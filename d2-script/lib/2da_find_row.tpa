//functions that automate some simple actions with 2da files
//all functions available as PATCH or ACTION (except no_backstab)
//for ACTION, you need to set the 2da resname as a STR_VAR

/*functions:
2da_find_row
2da_find_row_set
2da_find_row_delete
2da_find_column
no_backstab
*/

////////////////////////////////////////////////////////////

//search an entry and find the %row_number%
//just set the row_name (also set col_read to column number if changing)
//useful for finding mod-added rows in 2da files (ex. in kitlist.2da)

DEFINE_PATCH_FUNCTION 2da_find_row

  INT_VAR col_read = 0    // 2da column to read, default = 0 (1st column)
          col_count = 2    // required column count
		  
  STR_VAR row_name = ~~    // name to search for in the column
  
  RET     row_number    // gives the row number with the row_name (returns last row if no entry)
          columns    // required columns for row_number (set by col_count)
   
 
BEGIN

  SET columns = (0 + %col_count%)
  COUNT_2DA_ROWS columns row_count    // row_count = # rows with the required amount of columns
  SET row_number = (row_count)
  
  FOR (row = 1; row < row_count; ++row) BEGIN    // checks %row% if less than %row_count%, ++row increments by +1
    READ_2DA_ENTRY row %col_read% columns ~match~    // read table entry, and stores in variable %match%
    PATCH_IF ~%match%~ STRING_EQUAL_CASE ~%row_name%~ BEGIN
      SET row_number = %row%
    END
  END
	
END

////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION 2da_find_row

  INT_VAR col_read = 0    // 2da column to read, default = 0 (1st column)
          col_count = 2    // required column count
		  
  STR_VAR row_name = ~~    // name to search for in the column
          2da = ~~    // 2da file to read
  
  RET     row_number    // gives the row number with the row_name (returns last row if no entry)
          columns    // required columns for row_number (set by col_count)
   
 
BEGIN

COPY_EXISTING ~%2da%.2DA~ ~override~

  SET columns = (0 + %col_count%)
  COUNT_2DA_ROWS columns row_count    // row_count = # rows with the required amount of columns
  SET row_number = (row_count)
  
  FOR (row = 1; row < row_count; ++row) BEGIN    // checks %row% if less than %row_count%, ++row increments by +1
    READ_2DA_ENTRY row %col_read% columns ~match~    // read table entry, and stores in variable %match%
    PATCH_IF ~%match%~ STRING_EQUAL_CASE ~%row_name%~ BEGIN
      SET row_number = %row%
    END
  END

END

////////////////////////////////////////////////////////////

//search an entry and write a new entry in the same row
//you can even overwrite the entry being searched (read and write to same column)
//will set entries for multiple rows if multiple matches are found

DEFINE_PATCH_FUNCTION 2da_find_row_set

  INT_VAR col_read = 0    // 2da column to read, default = 0 (1st column)
          col_count = 2    // required column count
          col_write = 1    // SET column to write %entry% (default = 2nd column)
  
  STR_VAR row_name = ~~    // name to search for in the column
          entry = ~0~    // SET new entry
		  
  RET     row_number    // gives the row number with the row_name (returns last row if no entry)
          columns    // required columns for row_number (set by col_count)
     
 
BEGIN

  SET columns = (0 + %col_count%)
  COUNT_2DA_ROWS columns row_count    // row_count = # rows with the required amount of columns
  SET row_number = (row_count)
  
  FOR (row = 1; row < row_count; ++row) BEGIN    // checks %row% if less than %row_count%, ++row increments by +1
    READ_2DA_ENTRY row %col_read% columns ~match~    // read table entry, and stores in variable %match%
    PATCH_IF ~%match%~ STRING_EQUAL_CASE ~%row_name%~ BEGIN
      SET_2DA_ENTRY %row% %col_write% %columns% ~%entry%~
      SET row_number = %row%
    END
  END

END

////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION 2da_find_row_set

  INT_VAR col_read = 0    // 2da column to read, default = 0 (1st column)
          col_count = 2    // required column count
          col_write = 1    // SET column to write %entry% (default = 2nd column)
  
  STR_VAR row_name = ~~    // name to search for in the column
          entry = ~0~    // SET new entry
          2da = ~~    // 2da file to read

  RET     row_number    // gives the row number with the row_name (returns last row if no entry)
          columns    // required columns for row_number (set by col_count)
     
 
BEGIN

COPY_EXISTING ~%2da%.2DA~ ~override~

  SET columns = (0 + %col_count%)
  COUNT_2DA_ROWS columns row_count    // row_count = # rows with the required amount of columns
  SET row_number = (row_count)
  
  FOR (row = 1; row < row_count; ++row) BEGIN    // checks %row% if less than %row_count%, ++row increments by +1
    READ_2DA_ENTRY row %col_read% columns ~match~    // read table entry, and stores in variable %match%
    PATCH_IF ~%match%~ STRING_EQUAL_CASE ~%row_name%~ BEGIN
      SET_2DA_ENTRY %row% %col_write% %columns% ~%entry%~
      SET row_number = %row%
    END
  END

END

////////////////////////////////////////////////////////////

//search an entry and delete the entire row
//will delete multiple rows if multiple matches are found
//can also return the row_number to add a new line at the same spot (with INSERT_2DA_ROW)

DEFINE_PATCH_FUNCTION 2da_find_row_delete

  INT_VAR col_read = 0    // 2da column to read, default = 0 (1st column)
          col_count = 2    // required column count
  
  STR_VAR row_name = ~~    // name to search for in the column
  
  RET     row_number    // gives the row number of deleted row (returns last row if no entry)
          columns    // required columns for row_number (set by col_count)
     
 
BEGIN

  SET columns = (0 + %col_count%)
  COUNT_2DA_ROWS columns row_count    // row_count = # rows with the required amount of columns
  SET row_number = (row_count)
  
  FOR (row = (row_count - 1); row > 0; row -= 1) BEGIN    // checks %row%, starting from bottom
    READ_2DA_ENTRY row %col_read% columns ~match~    // read table entry, and stores in variable %match%
    PATCH_IF ~%match%~ STRING_EQUAL_CASE ~%row_name%~ BEGIN
      REMOVE_2DA_ROW %row% %columns%
      SET row_number = %row%
    END
  END
	
END

////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION 2da_find_row_delete

  INT_VAR col_read = 0    // 2da column to read, default = 0 (1st column)
          col_count = 2    // required column count
  
  STR_VAR row_name = ~~    // name to search for in the column
          2da = ~~    // 2da file to read

  RET     row_number    // gives the row number of deleted row (returns last row if no entry)
          columns    // required columns for row_number (set by col_count)
     
 
BEGIN

COPY_EXISTING ~%2da%.2DA~ ~override~

  SET columns = (0 + %col_count%)
  COUNT_2DA_ROWS columns row_count    // row_count = # rows with the required amount of columns
  SET row_number = (row_count)
  
  FOR (row = (row_count - 1); row > 0; row -= 1) BEGIN    // checks %row%, starting from bottom
    READ_2DA_ENTRY row %col_read% columns ~match~    // read table entry, and stores in variable %match%
    PATCH_IF ~%match%~ STRING_EQUAL_CASE ~%row_name%~ BEGIN
      REMOVE_2DA_ROW %row% %columns%
      SET row_number = %row%
    END
  END
	
END

////////////////////////////////////////////////////////////

//search an entry and find the %col_number%
//default INT_VARs should usually search the row with column headers
//useful for finding mod-added columns in 2da files (ex. in CHARSND.2da)

DEFINE_PATCH_FUNCTION 2da_find_column

  INT_VAR row_read = 1    // 2da row to read
          col_count = 2    // required column count
		  
  STR_VAR col_name = ~~    // name to search for in the column
  
  RET     col_number    // gives the column number with the col_name (returns last column if no entry)
 
 
BEGIN
      
  COUNT_2DA_COLS cols    // stores total column # in %cols%
  SET col_total = (%cols% - 1)    // reduce %col_total% by 1 to account for starting at column 0
  SET col_number = (%cols%)
  
  FOR (col = 1; col < col_total; ++col) BEGIN    // checks %col% if less than %col_total%
    READ_2DA_ENTRY %row_read% col %col_count% ~match~    // read table entry, and stores in variable %match%
    PATCH_IF ~%match%~ STRING_EQUAL_CASE ~%col_name%~ BEGIN
      SET col_number = (%col% + 1)    // plus 1 to add column 0 to %col_number%
    END
  END
	
END

////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION 2da_find_column

  INT_VAR row_read = 1    // 2da row to read
          col_count = 2    // required column count
		  
  STR_VAR col_name = ~~    // name to search for in the column
          2da = ~~    // 2da file to read

  RET     col_number    // gives the column number with the col_name (returns last column if no entry)
 
 
BEGIN

COPY_EXISTING ~%2da%.2DA~ ~override~

  COUNT_2DA_COLS cols    // stores total column # in %cols%
  SET col_total = (%cols% - 1)    // reduce %col_total% by 1 to account for starting at column 0
  SET col_number = (%cols%)
  
  FOR (col = 1; col < col_total; ++col) BEGIN    // checks %col% if less than %col_total%
    READ_2DA_ENTRY %row_read% col %col_count% ~match~    // read table entry, and stores in variable %match%
    PATCH_IF ~%match%~ STRING_EQUAL_CASE ~%col_name%~ BEGIN
      SET col_number = (%col% + 1)    // plus 1 to add column 0 to %col_number%
    END
  END
	
END

////////////////////////////////////////////////////////////

//this ACTION function removes a kit from all 3 backstab-related 2das
//you can use the variable %kit% as a synonym for %row_name%

DEFINE_ACTION_FUNCTION no_backstab
  
  STR_VAR row_name = ~~    // internal kit name
          kit = ~~    // internal kit name (alt)
     
 
BEGIN

COPY_EXISTING ~backstab.2DA~ ~override~
  COUNT_2DA_ROWS 2 row_count    // row_count = # rows with the required amount of columns  
  FOR (row = 1; row < row_count; ++row) BEGIN    // checks %row% if less than %row_count%, ++row increments by +1
    READ_2DA_ENTRY row 0 2 ~match~    // read table entry, and stores in variable %match%
    PATCH_IF ((~%match%~ STRING_EQUAL_CASE ~%row_name%~) OR 
              (~%match%~ STRING_EQUAL_CASE ~%kit%~)) BEGIN
      REMOVE_2DA_ROW %row% 2
    END
  END
BUT_ONLY
  
COPY_EXISTING ~crippstr.2DA~ ~override~
  COUNT_2DA_ROWS 2 row_count    // row_count = # rows with the required amount of columns  
  FOR (row = 1; row < row_count; ++row) BEGIN    // checks %row% if less than %row_count%, ++row increments by +1
    READ_2DA_ENTRY row 0 2 ~match~    // read table entry, and stores in variable %match%
    PATCH_IF ((~%match%~ STRING_EQUAL_CASE ~%row_name%~) OR 
              (~%match%~ STRING_EQUAL_CASE ~%kit%~)) BEGIN
      REMOVE_2DA_ROW %row% 2
    END
  END
BUT_ONLY

COPY_EXISTING ~sneakatt.2DA~ ~override~
  COUNT_2DA_ROWS 2 row_count    // row_count = # rows with the required amount of columns  
  FOR (row = 1; row < row_count; ++row) BEGIN    // checks %row% if less than %row_count%, ++row increments by +1
    READ_2DA_ENTRY row 0 2 ~match~    // read table entry, and stores in variable %match%
    PATCH_IF ((~%match%~ STRING_EQUAL_CASE ~%row_name%~) OR 
              (~%match%~ STRING_EQUAL_CASE ~%kit%~)) BEGIN
      REMOVE_2DA_ROW %row% 2
    END
  END
BUT_ONLY

END

////////////////////////////////////////////////////////////